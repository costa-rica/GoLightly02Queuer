import * as path from "path";
import logger from "./logger";
import {
  MeditationArrayElement,
  AudioConcatenatorCsvRow,
  ChildProcessResult,
} from "../types";
import { writeAudioConcatenatorCsv, generateCsvFilename } from "./csvWriter";
import { spawnChildProcess, buildChildProcessEnv } from "./childProcessSpawner";

/**
 * Generate AudioConcatenator CSV from meditation data and ElevenLabs output files
 * @param meditationElements - Array of meditation elements
 * @param elevenLabsFiles - Array of file paths generated by ElevenLabs (in order)
 * @returns CSV file path
 */
export function generateAudioConcatenatorCsv(
  meditationElements: MeditationArrayElement[],
  elevenLabsFiles: string[],
): string {
  logger.info("Generating AudioConcatenator CSV from meditation data");

  const rows: AudioConcatenatorCsvRow[] = [];
  let elevenLabsFileIndex = 0;

  for (const element of meditationElements) {
    // Determine what goes in this row
    if (element.text && element.text.trim() !== "") {
      // This was a text element, use the corresponding ElevenLabs file
      if (elevenLabsFileIndex < elevenLabsFiles.length) {
        rows.push({
          id: element.id,
          audio_file_name_and_path: elevenLabsFiles[elevenLabsFileIndex],
          pause_duration: "", // No pause, just audio
        });
        elevenLabsFileIndex++;
      } else {
        logger.warn(
          `No ElevenLabs file found for element ${element.id} (text: "${element.text}")`,
        );
      }
    } else if (element.pause_duration) {
      // This is a pause element
      rows.push({
        id: element.id,
        audio_file_name_and_path: "", // No audio file, just pause
        pause_duration: element.pause_duration,
      });
    } else if (element.sound_file) {
      // This is a pre-existing sound file - construct full path
      const soundFilePath = path.join(
        process.env.PATH_MP3_SOUND_FILES!,
        element.sound_file,
      );
      rows.push({
        id: element.id,
        audio_file_name_and_path: soundFilePath,
        pause_duration: "", // No pause, just audio
      });
    } else {
      logger.warn(
        `Element ${element.id} has no text, pause_duration, or sound_file - skipping`,
      );
    }
  }

  if (rows.length === 0) {
    throw new Error("No valid elements to process for AudioConcatenator");
  }

  const filename = generateCsvFilename("audio");
  const csvPath = writeAudioConcatenatorCsv(rows, filename);

  logger.info(
    `Generated AudioConcatenator CSV with ${rows.length} rows: ${csvPath}`,
  );

  return csvPath;
}

/**
 * Spawn AudioConcatenator child process
 * @param csvPath - Full path to the CSV file
 * @returns Process result with output
 */
export async function spawnAudioConcatenatorProcess(
  csvPath: string,
): Promise<ChildProcessResult> {
  logger.info(`Spawning AudioConcatenator child process with CSV: ${csvPath}`);

  const audioConcatenatorPath = process.env.PATH_TO_AUDIO_FILE_CONCATENATOR;
  if (!audioConcatenatorPath) {
    throw new Error(
      "PATH_TO_AUDIO_FILE_CONCATENATOR environment variable not set",
    );
  }

  const childAppName =
    process.env.NAME_CHILD_PROCESS_AUDIO_FILE_CONCATENATOR ||
    "AudioFileConcatenator01";

  // Build environment for child process
  // The AudioConcatenator needs PATH_AND_FILENAME_AUDIO_CSV_FILE
  const env = buildChildProcessEnv(childAppName, {
    PATH_AND_FILENAME_AUDIO_CSV_FILE: csvPath,
  });

  // Execute npm start in the AudioConcatenator service directory
  const result = await spawnChildProcess("npm", ["start"], {
    cwd: audioConcatenatorPath,
    env,
  });

  if (!result.success) {
    logger.error(`AudioConcatenator process failed: ${result.error?.message}`);
    throw new Error(
      `AudioConcatenator process failed with exit code: ${result.exitCode}`,
    );
  }

  logger.info("AudioConcatenator process completed successfully");

  return result;
}

/**
 * Parse AudioConcatenator output to extract final file path
 * @param stdout - Standard output from AudioConcatenator process
 * @returns Final MP3 file path
 */
export function parseAudioConcatenatorOutput(stdout: string): string | null {
  logger.info("Parsing AudioConcatenator output for final file path");

  const lines = stdout.split("\n");

  // Look for the output file path
  // The AudioConcatenator outputs: "Output: PATH_MP3_OUTPUT/YYYYMMDD/output_YYYYMMDD_HHMMSS.mp3"
  for (const line of lines) {
    // Look for lines containing the output path pattern
    const match = line.match(/(?:Output|Saved to|Created):\s*(.+\.mp3)/i);
    if (match && match[1]) {
      const filePath = match[1].trim();
      logger.info(`Found final output file: ${filePath}`);
      return filePath;
    }

    // Alternative: look for file paths in the output directory
    const pathMatch = line.match(/\/.*output_\d{8}_\d{6}\.mp3/);
    if (pathMatch) {
      const filePath = pathMatch[0].trim();
      logger.info(`Found final output file: ${filePath}`);
      return filePath;
    }
  }

  logger.warn(
    "Could not find final output file path in AudioConcatenator output",
  );
  return null;
}

/**
 * Run complete AudioConcatenator workflow
 * @param meditationElements - Array of meditation elements
 * @param elevenLabsFiles - Array of file paths generated by ElevenLabs
 * @returns Final MP3 file path
 */
export async function runAudioConcatenatorWorkflow(
  meditationElements: MeditationArrayElement[],
  elevenLabsFiles: string[],
): Promise<string> {
  logger.info("Starting AudioConcatenator workflow");

  // Generate CSV
  const csvPath = generateAudioConcatenatorCsv(
    meditationElements,
    elevenLabsFiles,
  );

  // Spawn child process
  const result = await spawnAudioConcatenatorProcess(csvPath);

  // Parse output to get final file path
  const finalFilePath = parseAudioConcatenatorOutput(result.stdout);

  if (!finalFilePath) {
    throw new Error(
      "Failed to get final output file path from AudioConcatenator",
    );
  }

  logger.info(`AudioConcatenator workflow completed: ${finalFilePath}`);

  return finalFilePath;
}
