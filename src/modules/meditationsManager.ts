import * as path from "path";
import { Meditation, ContractUsersMeditations } from "./database";
import logger from "./logger";

/**
 * Parse full file path to extract directory path and filename
 * @param fullPath - Full path to the file (e.g., "/path/to/output_20260202_153045.mp3")
 * @returns Object with filePath (directory), filename, and title (filename without extension)
 */
export function parseFilePath(fullPath: string): {
  filePath: string;
  filename: string;
  title: string;
} {
  // Extract the filename (everything after the last "/")
  const filename = path.basename(fullPath);

  // Extract the directory path (everything before the last "/", including the trailing "/")
  const dirPath = path.dirname(fullPath);
  const filePath = dirPath + "/";

  // Extract title (filename without extension)
  const title = path.parse(filename).name;

  return { filePath, filename, title };
}

/**
 * Create Meditation record in database
 * @param fullPath - Full path to the meditation MP3 file
 * @param providedTitle - Optional title from request (overrides auto-generated)
 * @param providedDescription - Optional description from request
 * @returns Created Meditation record
 */
export async function createMeditationRecord(
  fullPath: string,
  providedTitle?: string,
  providedDescription?: string,
): Promise<any> {
  logger.info(`Creating Meditation record for: ${fullPath}`);

  const { filePath, filename, title: autoGeneratedTitle } = parseFilePath(fullPath);

  // Use provided title if available, otherwise use auto-generated title
  const title = providedTitle || autoGeneratedTitle;

  logger.info(
    `Parsed path - filePath: ${filePath}, filename: ${filename}, title: ${title}`,
  );

  if (providedTitle) {
    logger.info(`Using provided title: ${providedTitle}`);
  }

  const meditation = await Meditation.create({
    title,
    description: providedDescription || null,
    filename,
    filePath,
  });

  logger.info(`Meditation record created successfully: ID ${meditation.id}`);

  return meditation;
}

/**
 * Create ContractUsersMeditations record to link user with meditation
 * @param userId - User ID
 * @param meditationId - Meditation ID
 * @returns Created ContractUsersMeditations record
 */
export async function createUserMeditationContract(
  userId: number,
  meditationId: number,
): Promise<any> {
  logger.info(
    `Creating ContractUsersMeditations record for userId: ${userId}, meditationId: ${meditationId}`,
  );

  const contract = await ContractUsersMeditations.create({
    userId,
    meditationId,
  });

  logger.info(
    `ContractUsersMeditations record created successfully: ID ${contract.id}`,
  );

  return contract;
}

/**
 * Create Meditation record and link to user after AudioConcatenator completes
 * @param fullPath - Full path to the meditation MP3 file
 * @param userId - User ID who requested the meditation
 * @param title - Optional title from request (overrides auto-generated)
 * @param description - Optional description from request
 * @returns Created Meditation record with ID
 */
export async function saveMeditationToDatabase(
  fullPath: string,
  userId: number,
  title?: string,
  description?: string,
): Promise<any> {
  logger.info(`Saving meditation to database for userId: ${userId}`);

  try {
    // Create Meditation record
    const meditation = await createMeditationRecord(fullPath, title, description);

    // Create ContractUsersMeditations record
    await createUserMeditationContract(userId, meditation.id);

    logger.info(
      `Meditation saved successfully to database: Meditation ID ${meditation.id}`,
    );

    return meditation;
  } catch (error) {
    logger.error("Failed to save meditation to database:", error);
    throw new Error("Failed to save meditation to database");
  }
}
